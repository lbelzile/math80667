# Completely randomized designs with one factor {#onewayanova}

In completely randomized experiments, we are solely interested in the effect of treatment variables. This chapter describes the most simple experimental setup one can consider, which consists in comparing the average of a single outcome variable with $K$ different treatments levels, each defining a sub-population differing only in the treatment they received. The global hypothesis of interest is whether the mean of all of the sub-populations are equal. 


The basic assumption of most designs is that we can decompose the outcome into two components [@Cox:1958]
\begin{align}
\begin{pmatrix} \text{quantity depending only } \\ 
\text{on the particular unit} 
\end{pmatrix} + 
\begin{pmatrix} \text{quantity depending} \\
 \text{on the treatment used}\end{pmatrix}
 (\#eq:additive)
\end{align}
This **additive** decomposition further assumes that each unit is unaffected by (i.e., independent of) the treatment of the other units and that the average effect of the treatment is constant. This notably means that usually the difference between treatments can be estimated by the difference in sample means


:::{ .example name="Additivity and transformations"}

Chapter 2 of @Cox:1958 discusses the assumption of additivity and provides useful examples showing when it cannot be taken for granted. One of them, Example 2.3, is a scenario in which the experimental units are participants and they are asked to provide a ranking of different kindergarden students on their capacity to interact with others in games, ranked on a scale of 0 to 100. A random group of students receives additional orthopedagogical support, while the balance is in the business-as-usual setting (control group). Since there are intrinsic differences at the student level, one could consider a **paired experiment** and take as outcome the difference in sociability scores at the beginning and at the end of the school year. 

One can expect the treatment to have more impact on people with low sociability skills who were struggling to make contacts: a student who scored 50 initially might see an improvement of 20 points with support relative to 10 in the business-as-usual scenario, whereas another who is well integrated and scored high initially may see an improvement of only 5 more had (s)he been assigned to the support group. This implies that the treatment effects are not constant over the scale, a violation of the additivity assumption. One way to deal with this is via transformations: @Cox:1958 discusses the transformation $\log\{(x+0.5)/(50-x)\}$ to reduce the warping due to scale. 

:::

Another example is in experiments where the effect of treatment is multiplicative, so that the output is of the form
\begin{align*}
\begin{pmatrix} \text{quantity depending only } \\ 
\text{on the particular unit} 
\end{pmatrix} \times
\begin{pmatrix} \text{quantity depending} \\
 \text{on the treatment used}\end{pmatrix}
\end{align*}
Usually, this arises for positive responses and treatments, in which case taking natural logarithms on both sides, with $\log(xy) = \log x + \log y$ yields again an additive. 

:::{ .example name="Inadequacy of additivity based on context"}

This example is adapted from @Cox:1958, Example 2.2. Children suffering from attention deficit hyperactivity disorder (ADHD) may receive medication to increase their attention span, measured on a scale of 0 to 100, with 0 indicating normal attention span. An experiment can be designed to assess the impact of a standardized dose in a laboratory by comparing performances of students on a series of task before and after, when to a placebo. To make a case, suppose that students with ADHD fall into two categories: low symptoms and strong symptoms. In the low symptom group, the average attention is 8 per cent with the drug and 12 per cent with the placebo, whereas for people with strong symptoms, the average is 40 per cent among treated and 60 per cent with the placebo. If these two categories are equally represented in the experiment and the population, we would estimate an average reduction of 12 percent in the score (thus higher attention span among treated). Yet, this quantity is artificial, and a better measure would be that symptoms are for the treatment are 2/3 of those of the control (the ratio of proportions).

:::

Equation \@ref(eq:additive) also implies that the effect of the treatment is constant for all individuals. This often isn't the case: in an experimental study on the impact of teaching delivery type (online, hybrid, in person), it may be that the response to the choice of delivery mode depends on the different preferences of learning types (auditory, visual, kinestetic, etc.) Thus, recording additional measurements that are susceptible to interact may be useful; likewise, treatment allotment must factor in this variability should we wish to make it detectable.

## Hypothesis tests for the one-way analysis of variance 

A **one-way analysis of variance** compares the sample averages of each treatment group $T_1, \ldots, T_K$ to try and determine if the population averages could be the same. Since we have $K$ groups, there will be $K$ averages (one per group) to estimate. 

Let $\mu_1, \ldots, \mu_K$ denote the expectation (theoretical mean) of each of the $K$ sub-populations defined by the different treatments. Lack of difference between treatments is equivalent to equality of means, which translates into the hypotheses
\begin{align*}
\mathscr{H}_0: & \mu_1 = \cdots = \mu_K \\
\mathscr{H}_a: & \text{at least two treatments have different averages, }
\end{align*}
The null hypothesis is, as usual, a single numerical value, $\mu$. The alternative consists of all potential scenarios for which not all expectations are equal. Going from $K$ averages to one requires imposing $K-1$ restrictions (the number of equality signs), as the value of the global mean $\mu$ is left unspecified. 

### Parametrizations


The most natural parametrization is in terms of group averages: the (theoretical unknown) average for treatment $T_j$ is $\mu_j$, so we obtain $K$ parameters $\mu_1, \ldots, \mu_K$ whose estimates are the sample averages $\widehat{\mu}_1, \ldots, \widehat{\mu}_K$. One slight complication arising from the above is that the values of the population average are unknown, so this formulation is ill-suited for hypothesis testing because none of the $\mu_i$ values are known in practice and we need to make comparisons in terms of a known numerical value. 

The most common parametrization is in terms of **constrasts** (or mean differences) relative to a reference group (say $T_1$). The theoretical average of each group is written as $\mu_1 + a_i$ for treatment $T_i$, where $a_1=0$ for $T_1$ and $a_i = \mu_i-\mu_1$ otherwise. The parameters are $\mu_1, a_2, \ldots, a_K$.

An equivalent formulation writes for each treatment group the average of subpopulation $j$ as $\mu_j = \mu + \delta_j$, where $\delta_j$ is the difference between the treatment average $\mu_j$ and the global average of all groups. Imposing the constraint $\delta_1 + \cdots + \delta_K=0$ ensures that the average of effects equals $\mu$. Thus, if we know any $K-1$ of $\{\delta_1, \ldots, \delta_K\}$, we automatically can deduce the last one is automatically known. 

:::{ .example name="Impact of encouragement on teaching"}

In **R**, the `lm` function fits a linear model based on a formula of the form `response ~ explanatory`. If the explanatory is categorical (i.e., a factor), the parameters of this model are the intercept, which is the sample average of the baseline group and the other parameters are simply contrasts, i.e., the $a_i$'s.

In the sum-to-zero parametrization, obtained with `contrasts = list(... = contr.sum)`, where the ellipsis is replaced by the name of the categorical variable. In this parametrization, the intercept is the average of each treatment average, $(\widehat{\mu}_1 + \cdots + \widehat{\mu}_5)/5$; this need not coincide with the (overall) mean of the response $\widehat{\mu} = \overline{y}$ unless the sample is balanced, meaning that the number of observations in each group is the same. The other coefficients of the sum-to-zero parametrization are the differences between this intercept and the group means. Since the group means is zero, we can deduce that of the last group from the sum of the others.


We show the function call to fit a one-way ANOVA in the different parametrizations along with the sample average of each arithmetic group (the two controls who were taught separately and the groups that were praised, reproved and ignored in the third class). Note that the omitted category changes depending on the parametrization.

```{r arithmeticLoadData, eval = TRUE, echo = FALSE, cache = TRUE, message = FALSE, error = FALSE}
url <- "https://edsm.rbind.io/data/arithmetic.csv"
arithmetic <- read_csv(url, show_col_types = FALSE) %>%
  mutate(group = factor(group,  
                        levels = LETTERS[1:5], 
                        labels = c("control 1",
                                   "control 2",
                                   "praised",
                                   "reproved",
                                   "ignored")))
summary_stats <- 
  arithmetic %>% 
  group_by(group) %>%
  summarize(mean = mean(score))
```
```{r arithmeticParam, eval = TRUE, echo = TRUE, cache = TRUE}
mod_contrast <- lm(score ~ group, 
                   data = arithmetic)
mod_sum2zero <- lm(score ~ group, 
                   data = arithmetic,
                   contrasts = list(group = contr.sum))
```

```{r tableanovaparam, echo = FALSE, eval = TRUE}
summary_stats <- summary_stats %>% 
  add_row(tibble(group = factor("intercept"), 
                 mean = NA), .before = 1) %>%
  add_column(contrasts = c(coef(mod_contrast)[1], NA, coef(mod_contrast)[-1]),
             "sum-to-zero" = c(coef(mod_sum2zero), NA))
options(knitr.kable.NA = '')

knitr::kable(summary_stats,
  digits = c(0,2,2,2),
  caption = "Coefficients of the analysis of variance model for the arithmetic scores using different parametrizations.")
```

:::



We can still assess the hypothesis by comparing the sample means in each group, which are noisy estimates of the expectation: their inherent variability will limit our ability to detect differences in mean if the signal-to-noise ratio is small.

```{r samplevar2, eval = FALSE, echo = FALSE, fig.cap = "Three samples from hypothetical populations with a common variance, but different means."}
set.seed(1234)
samp <- data.frame(dat = rep(c(2,10,5), each = 10) +  rt(n = 30, df = 4),
                   group = factor(rep(1:3, each = 10L)))
ggplot(data = samp,
       aes(x = group, y = dat, col = group)) +
  geom_point() +
  geom_jitter() +
  labs(col = "sample", y = "observations", x = "sample number") +
  theme(legend.position = "none") +
  stat_summary(fun = mean,
               geom = "point",
               shape = 95,
               size = 20)
```

## Sum of square decomposition

The following section tries to shed some light into how the $F$-test statistic works as a summary of evidence: it isn't straightforward in the way it appears. 




### Mathematical decomposition of sum of squares

Proceed if you want to see the mathematical intuition behind
The usual notation for this decomposition is the following: suppose $y_{ik}$ represents the $i$th person in the $k$th treatment group ($k=1, \ldots, K$) and the sample size $n$ can be split between groups as $n_1, \ldots, n_K$; in the case of a balanced sample, $n_1=\cdots=n_K = n/K$. We denote by $\widehat{\mu}_k$ the sample average in group $k$ and $\widehat{\mu}$ the overall average $(y_{11} + \cdots + y_{n_KK})/n = \sum_k  \sum_i y_{ik}$, where $\sum_i$ denotes the sum over all individuals in the group. 
Under the null model, all groups have the same mean, so the natural estimator is the sample average $\widehat{\mu}$ and likewise the group averages $\widehat{\mu}_1, \ldots, \widehat{\mu}_K$ are the correct estimators if each group has a (potentially) different mean. The more complex, which has more parameters, will always fit better because it has more possibility to accommodate differences observed in a group, even if these are spurious.
The sum of squares measures the (squared) distance between the observation and the fitted values, with the terminology total, within and between sum of squares linked to the decomposition
\begin{align*}
\underset{\text{total sum of squares}}{{\sum_{i}\sum_{k} (y_{ik} - \widehat{\mu})^2}} &= \underset{\text{within sum of squares}}{\sum_i \sum_k (y_{ik} - \widehat{\mu}_k)^2} +  \underset{\text{between sum of squares}}{\sum_k n_i (\widehat{\mu}_k - \widehat{\mu})^2}.
\end{align*}
The term on the left is a measure of the variability for the null model ($\mu_1 = \cdots = \mu_K$) under which all observations are predicted by the overall average $\widehat{\mu}$. The within sum of squares measures likewise the distance between the two. We can measure how much worst we do with the alternative model (different average per group) relative to the null by calculating the between sum of square. This quantity in itself varies with the sample size (the more observations, the larger it is) so we must standardize as usual this quantity so that we have a suitable benchmark. In large samples, the $F$ statistic 

The $F$-statistic is 
\begin{align}
F = \frac{\text{between-group variability}}{\text{within-group variability}} = \frac{\text{between sum of squares}/(K-1)}{\text{within sum of squares}/(n-K)}
(\#eq:Fstatheuristic)
\end{align}
If there is no difference in mean, the _F_-statistic follows in large sample a _F_-distribution, whose shape is governed by two parameters named degrees of freedom which appear in eq.\@ref(eq:Fstatheuristic) as scaling factors to ensure proper standardization. The first is the number of restrictions imposed by the null hypothesis ($K-1$, the number of groups minus one for the one-way analysis of variance), and the second is the number of observations minus the number of *parameters estimates* for the mean ($n-K$, where $n$ is the overall sample size and $K$ is the number of groups).^[There are only $K$ parameter estimates for the mean, since the overall mean is full determined by the other averages with $n\widehat{\mu} =n_1\widehat{\mu}_1 + \cdots + n_K \widehat{\mu}_K$.]

Figure \@ref(fig:squareddistanova) shows how the difference between these distances can encompass information that the null is wrong. The sum of squares is obtained by computing the squared length of these vectors and adding them up. The left panel shows strong signal-to-noise ratio, so that, on average, the black segments are much longer than the colored ones. This indicates that the model obtained by letting each group have its own mean is much better than the other. The picture in the right panel is not as clear: on average, the colored arrows are shorter, but the difference in length is much smaller relative to the colored arrows.

```{r squareddistanova, eval = TRUE, echo = FALSE, fig.cap = "Observations drawn from three groups from a model with a strong (left) and weak (right) signal-to-noise ratio, along with their sample mean (colored horizontal segments) and the overall average (horizontal line). Arrows indicate the magnitude of the difference between the observation and the (group/average) mean."}
set.seed(11234)
nobs <- 5
ng <- 3L
dat <- tibble(x = 1:(nobs*ng),
  observations = rnorm(ng*nobs, mean = 10, sd = 0.5) + 
                 rep(rnorm(n = ng, mean = 3), each = nobs),
  group = factor(x = rep(1:ng, each = nobs), 
                 labels = letters[1:ng]))
dat$fitted <- fitted(lm(observations ~ group, data = dat))
group_means <- dat %>%
  group_by(group) %>%
  summarise(gmean = mean(observations)) %>%
  mutate(x = 1 + (1:ng - 1)*nobs,
         xend = nobs + (1:ng - 1)*nobs)


dat2 <- tibble(x = 1:(nobs*ng),
  observations = rnorm(ng*nobs, mean = 10, sd = 8) + 
                 rep(rnorm(n = ng, mean = 0), each = nobs),
  group = factor(x = rep(1:ng, each = nobs), 
                 labels = letters[1:ng]))
dat2$fitted <- fitted(lm(observations ~ group, data = dat2))
group_means2 <- dat2 %>%
  group_by(group) %>%
  summarise(gmean = mean(observations)) %>%
  mutate(x = 1 + (1:ng - 1)*nobs,
         xend = nobs + (1:ng - 1)*nobs)

g1 <- ggplot() +
  geom_hline(yintercept = mean(dat$observations)) + 
  geom_segment(data = group_means, 
               aes(x = x, xend = xend, 
                   y = gmean, yend = gmean, 
                   col = group),
               lwd = 2) + 
  geom_segment(data = dat, 
               aes(x = x+0.1, 
                   xend = x+0.1, 
                   yend = mean(observations), 
                   y = observations),
               arrow = arrow(length =  unit(5,"pt"))) +
  geom_segment(data = dat, 
               aes(x = x - 0.1, 
                   xend = x - 0.1, 
                   yend = fitted, 
                   y = observations, col = group),
               arrow = arrow(length =  unit(5,"pt"))) +
   geom_segment(data = dat, alpha = 0.1,
              aes(x = x - 0.1,
                  xend = x + 0.1,
                  y = observations,
                  yend = observations)) +
  labs(y = "observation", x = "") + 
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        legend.position = "none")
g2 <- ggplot() +
  geom_hline(yintercept = mean(dat2$observations)) + 
  geom_segment(data = group_means2, 
               aes(x = x, xend = xend, 
                   y = gmean, yend = gmean, 
                   col = group),
               lwd = 2) + 
  geom_segment(data = dat2, 
               aes(x = x+0.1, 
                   xend = x+0.1, 
                   yend = mean(observations), 
                   y = observations),
               arrow = arrow(length =  unit(5,"pt"))) +
  geom_segment(data = dat2, 
               aes(x = x - 0.1, 
                   xend = x - 0.1, 
                   yend = fitted, 
                   y = observations, col = group),
               arrow = arrow(length =  unit(5,"pt"))) +
   geom_segment(data = dat2, alpha = 0.1,
              aes(x = x - 0.1,
                  xend = x + 0.1,
                  y = observations,
                  yend = observations)) +
  labs(y = "observation", x = "") + 
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        legend.position = "none")
g1 + g2
```  
  
If there is no mean difference (null), the numerator is an estimator of the population variance, and so is the denominator of \@ref(eq:Fstatheuristic). If there are many observations (and relatively fewer groups), the ratio is approximately one on average. 

```{r compareFnullalternative, fig.cap = "Null (left) and alternative (right) distributions for the one-way analysis of variance: if some of the group means are different, the curve gets shifted to the right. The shaded area is the type I error (null hypothesis) and the type II error (alternative hypothesis).", echo = FALSE, eval = TRUE, fig.height = 4}
g1 <- ggplot() + 
  stat_function(xlim = c(0, 8), 
                n = 1001,
                fun=df, args = list(df1 = 4, df2 = 80, ncp = 0)) + 
  stat_function(geom = "area", fill = "blue", alpha = 0.2,
                xlim = c(qf(0.95, 4,80),8), 
                n = 1001,
                fun=df, args = list(df1 = 4, df2 = 80, ncp = 0)) + 
  labs(x = "statistic", y = "density", subtitle = "null")
g2 <- ggplot() + 
  stat_function(xlim = c(0, 8), 
                n = 1001,
                fun=df, args = list(df1 = 4, df2 = 80, ncp = 3)) + 
  stat_function(geom = "area", fill = "blue", alpha = 0.2,
                xlim = c(0, qf(0.95, 4,80)), 
                n = 1001,
                fun=df, args = list(df1 = 4, df2 = 80, ncp = 3)) + 
  labs(x = "statistic", y = "density", subtitle = "alternative")
  
g1 + g2

```



```{r Fdist_permut, eval = FALSE, echo = FALSE, cache = TRUE}
n <- 100 # total sample size
set.seed(1234)
fake_data <- # sample fake data from normal(0,1)
  tibble::tibble(response = rnorm(n), 
                 group = factor(sample(letters[1:5], 
                                       size = n, 
                                       replace = TRUE)))
# randomly assign to groups a, b, ..., e with equal probability
group_mean <- 
  fake_data %>% 
  group_by(group) %>% # repeat this in each group
  summarize(mean = mean(response), # group average
            n = length(response)) # number of obs per group

# Fit ANOVA model using "lm"=linear model
fitted_anova <- lm(response ~ group, data = fake_data)
anova(fitted_anova)

Fstat <- fake_data %>% 
  specify(response ~ group) %>% 
  # formula: average response is group-specific
  hypothesise(null = "independence") %>% 
  # user permutation test
  infer::calculate(stat = "F") 

null_dist_permute <- 
  fake_data %>% 
  specify(response ~ group) %>% 
  hypothesise(null = "independence") %>% 
  generate(reps = 9999, type = "permute") %>%
  infer::calculate(stat = "F") 
null_dist_asympt <- 
  fake_data %>% 
  specify(response ~ group) %>%
  infer::calculate(stat = "F") 

graph <- null_dist_permute %>%
    visualize(method = "both", bins = 30) + 
    shade_p_value(Fstat,
                  direction = "greater")
knitr::kable(
afex::nice(
  mod <- afex::aov_ez(dv = "response", 
               id = "ID", 
               between = "group", 
               data = tibble::rowid_to_column(fake_data, "ID"))))
```


## Graphical representation

If we have a lot of data, it sometimes help to focus only on selected summary statistics. A box-and-whiskers plot (or boxplot) represents five numbers

- The box gives the quartiles, say $q_1$, $q_2$ (median) and $q_3$ of the distribution: 50\% of the observations are smaller or larger than $q_2$, 25\% are smaller than $q_1$ and 75\% are smaller than $q_3$ for the sample.


- The length of the whiskers is up to $1.5$ times the interquartiles range $q_3-q_1$ (the whiskers extend until the latest point in the interval, so the largest observation that is smaller than $q_3+1.5(q_3-q_1)$, etc.)
- Observations beyond the whiskers are represented by dots or circles, sometimes termed outliers. However, beware of this terminology: the larger the sample size, the more values will fall outside the whiskers (about 0.7\% for normal data). This is a drawback of boxplots, which were conceived at a time where big data didn't exist.

```{r boxplot, fig.cap = "Box-and-whiskers plot", echo = FALSE}
knitr::include_graphics('figures/01-intro-boxplot.png')
```

